Because of this, if you plan to write blocking IO code or code that could do a lot of CPU-intensive work, you need to know precisely which thread pool is bearing that workload and tune it accordingly. Doing blocking IO without considering this will likely result in poor performance in general; for example, when we have a global execution context (fork-join pool), and http4s are using it, you may see only a few requests per second being handled. At the same time, CPU usage sits at 5%. 

The most common place where a typical application will block is when it’s talking to a database via an old synchronous JDBC driver, network IO, or filesystem reads/writes. Unfortunately, none of the major databases provide asynchronous database drivers for the JVM, so your only option is blocking IO for most databases. In a similar situation with some libraries, we can face the code that performs long-running or blocking operations when a thread synchronously waits for something to happen, for example, waits for a lock to be acquired, a result set to be returned from a database, a timer to elapse, or bytes to be read from a socket such fetching resources from the internet/filesystem; you might want to run it in a separate thread or thread pool to prevent it from blocking your application's main thread. Blocking the main thread can lead to unresponsiveness in your application.

- The server engine should use **a separate thread pool** internally for handling IO. A thread in these thread pools should never execute an application’s code. 
- **Default thread pool** - This is where all of your application (async) code is executed
- You may dispatch work to other thread pools in certain circumstances. This may include CPU-heavy work or blocking IO work, such as database access. To do this, you should first create a `ThreadPool` / ```ExecutionContext```.

In a blocking environment, `thread-pool-executor` is better than `fork-join` because no work-stealing is possible, and a `fixed-pool-size` size should be used and set to the maximum size of the underlying resource.

### Many specific thread pools

When you want to do a lot of synchronous IO, you also want to control exactly how much of which types of operations your application does at once. You would only do non-blocking operations in the default execution context and then dispatch blocking operations to different execution contexts for those specific operations.